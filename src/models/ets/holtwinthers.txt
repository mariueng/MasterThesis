import os
from data import data_handler
from datetime import datetime as dt
from datetime import timedelta
import pandas as pd
import warnings
import itertools
import numpy as np
import scipy.stats as scipy
from statsmodels.tsa.holtwinters import ExponentialSmoothing


class Ets:
    def __init__(self):
        self.name = "ETS"
        today = dt.today()
        self.creation_date = str(today)[0:10] + "_" + str(today)[11:16]
        print("'{}' is instantiated\n".format(self.name))

    def get_name(self):
        return self.name

    def get_time(self):
        return self.creation_date

    def forecast(self, forecast_df):  # forecast_df is dataframe with ["Date", "Hour", "Forecast", "Upper", "Lower"]
        forecast = self.get_forecast(forecast_df)
        forecast_df["Forecast"] = forecast["forecast"]
        forecast_df["Upper"] = forecast["upper"]
        forecast_df["Lower"] = forecast["lower"]
        return forecast_df

    @staticmethod
    def get_forecast(forecast_df):
        warnings.filterwarnings("ignore")
        start_date = forecast_df.at[0, "Date"]
        days_back = 14
        train_start_date = start_date - timedelta(days=days_back)
        train_end_date = train_start_date + timedelta(days=days_back - 1)
        train = data_handler.get_data(train_start_date, train_end_date, ["System Price"], os.getcwd())
        model, model_fit = fit(train["System Price"].tolist())
        forecast, uppers, lowers = predict(model_fit, len(forecast_df))
        forecast_df["forecast"] = forecast
        forecast_df["upper"] = uppers
        forecast_df["lower"] = lowers
        return forecast_df


def fit(train, verbose=False):
    ets = ExponentialSmoothing(train, trend='add', seasonal='add', damped_trend=True,
                               seasonal_periods=24)
    model_fit = ets.fit()
    if verbose:
        print(model_fit.summary())
    return ets, model_fit


# Use model to predict
def predict(model_fit, steps):
    forecast = model_fit.predict(start=0, end=steps-1)
    print("Forecast: {}".format(forecast[0]))
    simulations = model_fit.simulate(nsimulations=steps, repetitions=100, error='add', random_errors="bootstrap",
                                     random_state=1)
    forecast = []
    uppers = []
    lowers = []
    for i in range(steps):
        pop = simulations[i]
        upper, lower = get_confidence_interval(pop, 0.95)
        print("Pop: {}".format(pop))
        print("Upper: {}".format(upper))
        print("Lower: {}".format(lower))
        uppers.append(upper)
        lowers.append(lower)
    return forecast, uppers, lowers


def get_confidence_interval(data, confidence):
    a = 1.0 * np.array(data)
    n = len(a)
    m, se = np.mean(a), scipy.sem(a)
    h = se * scipy.t.ppf((1 + confidence) / 2., n-1)
    return m+h, m-h,
